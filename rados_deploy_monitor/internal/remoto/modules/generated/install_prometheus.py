

################################################################################
# Generated by the meta modulegenerator
# Processed 6 files/modules:
#    /home/radon/uni/mrp/reps/meta/rados-deploy-monitor/rados_deploy_monitor/internal/util/fs.py
#    /home/radon/uni/mrp/reps/meta/rados-deploy-monitor/rados_deploy_monitor/internal/util/printer.py
#    /home/radon/uni/mrp/reps/meta/rados-deploy-monitor/rados_deploy_monitor/internal/remoto/modules/printer.py
#    /home/radon/uni/mrp/reps/meta/rados-deploy-monitor/rados_deploy_monitor/internal/remoto/env.py
#    /home/radon/uni/mrp/reps/meta/rados-deploy-monitor/rados_deploy_monitor/internal/remoto/modules/prometheus_install.py
#    /home/radon/uni/mrp/reps/meta/rados-deploy-monitor/rados_deploy_monitor/internal/remoto/modules/remoto_base.py
################################################################################


import urllib.request
import builtins
import zipfile
import sys
import configparser
import tempfile
import socket
import os
import subprocess
import shutil
from pathlib import Path
from enum import Enum
from zipfile import ZipFile, ZipInfo
################################################################################
# Created from file /home/radon/uni/mrp/reps/meta/rados-deploy-monitor/rados_deploy_monitor/internal/util/fs.py
# This file contains many functions to help interact 
# with the filesystem in an OS independent manner
# 
# This mainly is a wrapper around the system's os libraries.
# Quite a few handy tricks are stored here.
def abspath(path=os.path.dirname(sys.argv[0])):
    return os.path.abspath(path)
# Returns absolute path for a given file
def abspathfile(file):
    return os.path.abspath(os.path.dirname(file))
def basename(path):
    return os.path.basename(path)
def cp(path_src, path_dst):
    if isfile(path_src):
        shutil.copy2(path_src, path_dst)
    else:
        shutil.copytree(path_src, path_dst)
def cwd():
    return os.getcwd()
def dirname(path):
    return os.path.dirname(path)
def exists(path, *args):
    return os.path.exists(join(path,*args))
def isdir(path, *args):
    return os.path.isdir(join(path,*args))
def isemptydir(path, *args):
    try:
        next(ls(path, *args))
        return False
    except StopIteration as e:
        return True
def isfile(path, *args):
    return os.path.isfile(join(path,*args))
# Note: Returns always False on unsupported systems.
# Note: Be careful: Even if given symlink points to non-existing target, returns True
def issymlink(path, *args):
    return os.path.islink(join(path, *args))
# Resolve a symlink. With full_resolve, 
# we keep following links until we find end destination
def resolvelink(path, *args, full_resolve=True):
    return str(Path(join(path, *args)).resolve().absolute()) if full_resolve else os.readlink(join(path, *args))
def join(directory, *args):
    returnstring = directory
    for arg in args:
        returnstring = os.path.join(returnstring, str(arg))
    return returnstring
def ln(pointedloc, pointerloc, soft=True, is_dir=None):
    if soft: # Make softlink
        os.symlink(pointedloc, pointerloc, target_is_directory=isdir(pointedloc) if is_dir == None else is_dir)
    else: # Make hardlink
        os.link(pointedloc, pointerloc)
def ls(directory, only_files=False, only_dirs=False, full_paths=False, *args):
    ddir = join(directory, *args)
    if only_files and only_dirs:
        raise ValueError('Cannot ls only files and only directories')
    if sys.version_info >= (3, 5): # Use faster implementation in python 3.5 and above
        with os.scandir(ddir) as it:
            for entry in it:
                if (entry.is_dir() and not only_files) or (entry.is_file() and not only_dirs):
                    yield join(ddir, entry.name) if full_paths else entry.name
    else: # Use significantly slower implementation available in python 3.4 and below
        for entry in os.listdir(ddir):
            if (isdir(ddir, entry) and not only_files) or (isfile(ddir, entry) and not only_dirs):
                yield join(ddir, entry) if full_paths else entry
def mkdir(path, *args, exist_ok=False):
    os.makedirs(join(path, *args), exist_ok=exist_ok)
def mv(path_src, path_dst):
    shutil.move(path_src, path_dst)
def rm(directory, *args, ignore_errors=False):
    path = join(directory, *args)
    if isdir(path):
        shutil.rmtree(path, ignore_errors=ignore_errors)
    else:
        if ignore_errors:
            try:
                os.remove(path)
            except Exception as e:
                pass
        else:
            os.remove(path)
def sep():
    return os.sep
# Return size of file in bytes
def sizeof(directory, *args):
    path = join(directory, *args)
    if not isfile(path):
        raise RuntimeError('Error: "{}" is no path to a file'.format(path))
    return os.path.getsize(path)
def split(path):
    return path.split(os.sep)
# Touch-like command, does not emulate mtime if file already exists
def touch(path, *args):
    path = join(path, *args)
    if exists(path):
        raise RuntimeError('Error: "{}" already exists'.format(path))
    open(path, 'w').close()
def unpack(filename, extract_dir):
    if not filename.endswith('.zip'):
        shutil.unpack_archive(filename, extract_dir)
        return
    # Below code is taken from the shutil implementation: https://github.com/python/cpython/blob/78b2abca8e96b43f56ab1b9ad673aaa6bbe7e790/Lib/shutil.py#L1152-L1181
    # All credits for this code to them. We changed it to work with our zipfile object, which maintains file permissions. Also, we substituted a function to make directories with our own.
    if not zipfile.is_zipfile(filename):
        raise shutil.ReadError("%s is not a zip file" % filename)
    zip = _ZipFileWithpermissions(filename)
    try:
        for info in zip.infolist():
            name = info.filename
            # don't extract absolute paths or ones with .. in them
            if name.startswith('/') or '..' in name:
                continue
            target = join(extract_dir, *name.split('/'))
            if not target:
                continue
            mkdir(dirname(target), exist_ok=True)
            if not name.endswith('/'):
                # file
                data = zip.read(info.filename)
                f = open(target, 'wb')
                try:
                    f.write(data)
                finally:
                    f.close()
                    del data
                attr = info.external_attr >> 16
                if attr != 0:
                    os.chmod(target, attr)
    finally:
        zip.close()
class _ZipFileWithpermissions(ZipFile):
    '''Zipfile implementation that fixes https://bugs.python.org/issue15795. No one knows why this fix is not merged into the ZipFile project.'''
    if sys.version_info <= (3, 5):
        def extract(self, member, path=None, pwd=None):
            if not isinstance(member, ZipInfo):
                member = self.getinfo(member)
            if path is None:
                path = os.getcwd()
            ret_val = self._extract_member(member, path, pwd)
            attr = member.external_attr >> 16
            os.chmod(ret_val, attr)
            return ret_val
    else:
        def _extract_member(self, member, targetpath, pwd):
            if not isinstance(member, ZipInfo):
                member = self.getinfo(member)
            targetpath = super()._extract_member(member, targetpath, pwd)
            attr = member.external_attr >> 16
            if attr != 0:
                os.chmod(targetpath, attr)
            return targetpath
################################################################################


################################################################################
# Created from file /home/radon/uni/mrp/reps/meta/rados-deploy-monitor/rados_deploy_monitor/internal/util/printer.py
# The greater purpose of (functions in) this file is
# to convert strings to colored strings, which helps
# navigating the commandline interface
# Overridden print function to always flush.
# We need this practically everywhere when using ssh.
def print(*args, **kwargs):
    kwargs['flush'] = True
    return builtins.print(*args, **kwargs)
class Color(Enum):
    '''An enum to specify what color you want your text to be'''
    RED = '\033[1;31m'
    GRN = '\033[1;32m'
    YEL = '\033[1;33m'
    BLU = '\033[1;34m'
    PRP = '\033[1;35m'
    CAN = '\033[1;36m'
    CLR = '\033[0m'
# Print given text with given color
def printc(string, color, **kwargs):
    print(format(string, color), **kwargs)
# Print given success text
def prints(string, color=Color.GRN, **kwargs):
    print('[SUCCESS] {}'.format(format(string, color)), **kwargs)
# Print given warning text
def printw(string, color=Color.YEL, **kwargs):
    print('[WARNING] {}'.format(format(string, color)), **kwargs)
# Print given error text
def printe(string, color=Color.RED, **kwargs):
    print('[ERROR] {}'.format(format(string, color)), **kwargs)
# Format a string with a color
def format(string, color):
    if os.name == 'posix':
        return '{}{}{}'.format(color.value, string, Color.CLR.value)
    return string
################################################################################


################################################################################
# Created from file /home/radon/uni/mrp/reps/meta/rados-deploy-monitor/rados_deploy_monitor/internal/remoto/modules/printer.py
def print(*args, **kwargs):
    '''Print method overriding default, prints to stderr.'''
    kwargs['flush'] = True
    kwargs['file'] = sys.stderr
    
    return builtins.print('[{}] {}'.format(socket.gethostname(), args[0]), *(args[1:]), **kwargs) if any(args) else builtins.print(**kwargs)
################################################################################


################################################################################
# Created from file /home/radon/uni/mrp/reps/meta/rados-deploy-monitor/rados_deploy_monitor/internal/remoto/env.py
class Environment(object):
    '''Class to load and store persistent variables in a way that does not depend on OS environment vars, login shells, shell types, etc.'''
    def __init__(self):
        self._entered = False
        self._path = Environment.get_path()
        os.makedirs(Environment.get_storedir(), exist_ok=True)
        
        self.parser = configparser.ConfigParser()
        self.parser.optionxform=str
        if os.path.isfile(self._path):
            self.parser.read(self._path)
    @staticmethod
    def get_path():
        return os.path.join(Environment.get_storedir(), 'env.cfg')
    @staticmethod
    def get_storedir():
        return os.path.join(os.getenv('HOME'), '.rados_deploy_monitor')
    def get(self, key):
        '''Getter, different from "env[key]"" in that it does not throw.
        Returns:
            Found value on success, `None` otherwise.'''
        return self.parser['DEFAULT'][key] if key in self.parser['DEFAULT'] else None
    def set(self, key, value):
        '''Function to add a single key-valuepair. Note: For setting multiple keys, use a "with env:" block, followed by "env[key] = value" or "env.set(key, value)".'''
        self.parser['DEFAULT'][key] = value
        os.environ[key]= value
        if not self._entered:
            self.persist()
    def load_to_env(self):
        '''Loads all stored variables into the process environment.'''
        for key, value in self.parser['DEFAULT'].items():
            os.environ[key] = value
    def persist(self):
        with open(self._path, 'w') as file:
            self.parser.write(file)
    def __enter__(self):
        self._entered = True
        return self
    def __getitem__(self, key):
        return self.parser['DEFAULT'][key]
    def __setitem__(self, key, value):
        if not self._entered:
            raise NotImplementedError('Cannot directly set Environment variables. Use "env.set()", or "with env:"')
        else:
            os.environ[key]= value
            self.parser['DEFAULT'][key] = value
    def __exit__(self, exc_type, exc_value, traceback):
        self.persist()
        self._entered = False
################################################################################


################################################################################
# Created from file /home/radon/uni/mrp/reps/meta/rados-deploy-monitor/rados_deploy_monitor/internal/remoto/modules/prometheus_install.py
def _download_url(location, url, name='unspecified', silent=False, retries=5):
    '''Download a zip from an URL.
    Args:
        url (str): URL zip.
        name (optional str): Name for download to display when reporting errors.
        silent (optional bool): If set,  does not print.
        retries (optional int): Amount of retries before reporting errors.
    Returns:
        `True` on success, `False` otherwise.'''
    with tempfile.TemporaryDirectory() as tmpdir: # We use a tempfile to store the downloaded archive.
        archiveloc = join(tmpdir, url.split('/')[-1])
        if not silent:
            print('Fetching Prometheus node exporter from {}'.format(url))
        for x in range(retries):
            try:
                try:
                    rm(archiveloc)
                except Exception as e:
                    pass
                urllib.request.urlretrieve(url, archiveloc)
                break
            except Exception as e:
                if x == 0:
                    printw('Could not download {}, url={}. Retrying...'.format(name, url))
                elif x == retries-1:
                    printe('Could not download {}, url={}. {}'.format(name, url, e))
                    return False
        try:
            extractloc = join(tmpdir, 'extracted')
            mkdir(extractloc, exist_ok=True)
            unpack(archiveloc, extractloc)
            extracted_dir = next(ls(extractloc, only_dirs=True, full_paths=True)) # find out what the extracted directory is called. There will be only 1 extracted directory.
            rm(location, ignore_errors=True)
            mkdir(location)
            for x in ls(extracted_dir, full_paths=True): # Move every file and directory to the final location.
                mv(x, location)
            return True
        except Exception as e:
            printe('Could not extract {} zip file correctly, url={}. {}'.format(name, url, e))
            return False
def install_prometheus_node_exporter(location, node_exporter_url, force_reinstall, silent, retries):
    location = os.path.expanduser(location)
    if (not force_reinstall) and isfile(join(location, 'node_exporter')) and isfile('/usr/bin/node_exporter') and isfile('/etc/systemd/system/node_exporter.service'):
        prints('Acceptable node exporter installation detected.')
        return True
    rm(location, ignore_errors=True)
    mkdir(location)
    if (not isfile(location, 'node_exporter')) and not _download_url(location, node_exporter_url, name='Prometheus node exporter', silent=silent, retries=retries):
        return False
    if subprocess.call('sudo cp {} /usr/bin'.format(join(location, 'node_exporter')), shell=True) != 0:
        printe('Could not copy {} to /usr/bin. Location exists: {}'.format(join(location, 'node_exporter'), isfile(location, 'node_exporter')))
        print(str(socket.gethostname()))
        printe('cmd={}'.format('sudo cp {} /usr/bin'.format(join(location, 'node_exporter'))))
        return False
    cmd = """sudo python3 -c "
with open('/etc/systemd/system/node_exporter.service', 'w') as f:
    f.write('''
[Unit]
Description=Node Exporter
After=network.target
[Service]
Type=simple
ExecStart=/usr/bin/node_exporter
[Install]
WantedBy=multi-user.target
''')
exit(0)
"
"""
    if subprocess.call(cmd, shell=True) != 0:
        printe('Could not write systemd config.')
        return False
    if subprocess.call('sudo systemctl daemon-reload', shell=True) != 0:
        printe('Could not reload daemons.')
        return False
    return True
def install_prometheus_admin(location, node_admin_url, force_reinstall, silent, retries):
    location = os.path.expanduser(location)
    if (not force_reinstall) and isfile(join(location, 'prometheus')) and isfile('/usr/bin/prometheus') and isfile('/etc/systemd/system/prometheus.service'):
        prints('Acceptable admin installation detected.')
        return True
    rm(location, ignore_errors=True)
    mkdir(location)
    if (not isfile(location, 'prometheus')) and not _download_url(location, node_admin_url, name='Prometheus admin url', silent=silent, retries=retries):
        return False
    if subprocess.call('sudo cp {} /usr/bin'.format(join(location, 'prometheus')), shell=True) != 0:
        printe('Could not copy {} to /usr/bin'.format(join(location, 'prometheus')))
        return False
    cmd = """sudo python3 -c "
with open('/etc/systemd/system/prometheus.service', 'w') as f:
    f.write('''
[Unit]
Description=Prometheus
After=network.target
 
[Service]
Type=simple
ExecStart=/usr/bin/prometheus --config.file={}
 
[Install]
WantedBy=multi-user.target
''')
exit(0)
"
""".format(join(location, 'config.yml'))
    if subprocess.call(cmd, shell=True) != 0:
        printe('Could not write admin systemd config.')
        return False
    if subprocess.call('sudo systemctl daemon-reload', shell=True) != 0:
        printe('Could not reload daemons.')
        return False
    return True
################################################################################


################################################################################
# Created from file /home/radon/uni/mrp/reps/meta/rados-deploy-monitor/rados_deploy_monitor/internal/remoto/modules/remoto_base.py
# In case we use this module with remoto legacy connections (local, ssh), we need this footer.
if __name__ == '__channelexec__':
    for item in channel:
        channel.send(eval(item))
################################################################################

